package de.thm.mni.compilerbau.phases._02_03_parser;

import java_cup.runtime.*;
import de.thm.mni.compilerbau.utils.*;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;

parser code {:
  public void syntax_error(Symbol currentToken) {
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right));
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

/* Non-terminals */
terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals



non terminal Program program;
non terminal AssignStatement assignStatement;
non terminal Expression plusminus;
non terminal Expression divmulti;
non terminal Expression unaryMinus;
non terminal Expression primaryExpression;
non terminal Expression variableExpression;
non terminal ProcedureDeclaration procedure;
non terminal List<ParameterDeclaration> parameterlist;
non terminal parameter;
non terminal List<VariableDeclaration> declarationList;
non terminal declaration;
non terminal statement;
non terminal List<Statement> statementList;
non terminal IfStatement ifstatement;
non terminal WhileStatement whileStatement;
non terminal CompoundStatement compundStatement;
non terminal CallStatement callStatement;
non terminal EmptyStatement emptyStatment;
non terminal argList;
non terminal expression;
non terminal typeDeclaration;
non terminal ArrayTypeExpression arrayDeclaration;
non terminal List<GlobalDeclaration> globalDeclarations;
non terminal TypeExpression typeExpression;


start with program;


program ::= globalDeclarations:decList {:RESULT = new Program(new Position(decListleft,decListright),decList);:};


globalDeclarations ::= typeDeclaration:decl0 globalDeclarations:declList {:RESULT = List.cons(decl0,declList);:}
        |procedure:decl0 globalDeclarations:declList{:RESULT = List.cons(decl0,declList);:}
        | {:RESULT= List.nil();:};

procedure ::= PROC:proc IDENT:name LPAREN parameterlist:parameters RPAREN LCURL declarationList:varList statementList:statList RCURL
                {:RESULT= new ProcedureDeclaration(new Position());:};

typeExpression ::= IDENT | ARRAY LBRACK INTLIT RBRACK OF typeExpression;

declarationList ::= declaration declarationList | ;
declaration ::=  VAR IDENT COLON typeExpression SEMIC;

typeDeclaration ::= TYPE IDENT EQ typeExpression SEMIC;

statementList ::= statement statementList | emptyStatment;
emptyStatment ::= ;


ifstatement ::= IF:pos LPAREN expression:exp RPAREN statement:thenStm | IF LPAREN expression RPAREN statement ELSE statement ;

statement ::= SEMIC | assignStatement | ifstatement | whileStatement | compundStatement | callStatement;
whileStatement ::= WHILE LPAREN expression RPAREN statement;
compundStatement ::= LCURL statementList RCURL;
callStatement ::= IDENT LPAREN argList RPAREN SEMIC;
// LT, LE, GT, GE, NE, EQ;

expression ::= plusminus LT plusminus | plusminus LE plusminus | plusminus GT plusminus| plusminus GE plusminus| plusminus NE plusminus | plusminus EQ plusminus| plusminus;


argList ::= plusminus | plusminus COMMA argList | ;

parameterlist ::= parameter COMMA parameterlist | parameter | ;
parameter ::= IDENT COLON typeExpression | REF IDENT COLON typeExpression;

assignStatement ::= variableExpression ASGN plusminus SEMIC;

plusminus ::= plusminus:exp0 PLUS divmulti:exp1 {: RESULT= new BinaryExpression(new Position(exp0left,exp1right),Operator.ADD,exp0,exp1);:}
                | plusminus MINUS divmulti  {: RESULT= new BinaryExpression(new Position(exp0left,exp1right),Operator.SUB,exp0,exp1);:}
                | divmulti:exp {:RESULT= exp;:};
divmulti ::= divmulti STAR unaryMinus | divmulti SLASH unaryMinus | unaryMinus;
unaryMinus ::= MINUS  primaryExpression | primaryExpression;
primaryExpression ::= INTLIT | LPAREN plusminus RPAREN | variableExpression ;
variableExpression ::= IDENT | variableExpression LBRACK plusminus RBRACK;
